<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>Pizza Spider Finder 360</title>
<meta name="viewport" content="initial-scale=1,maximum-scale=1,user-scalable=no">
<link href="https://api.mapbox.com/mapbox-gl-js/v2.9.0-beta.2/mapbox-gl.css" rel="stylesheet">
<link href="https://fonts.googleapis.com/css2?family=IBM+Plex+Mono:wght@300;400;500;700&display=swap" rel="stylesheet">
<script src="https://api.mapbox.com/mapbox-gl-js/v2.9.0-beta.2/mapbox-gl.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@turf/turf@6/turf.min.js"></script>
<script src="https://d3js.org/d3.v4.min.js"></script>
<style>
body { 
    margin: 0; 
    padding: 0; 
    font-family: 'IBM Plex Mono', 'Courier New', monospace;
    background: #000;
    overflow: hidden;
}
#map { 
    position: absolute; 
    top: 0; 
    bottom: 0; 
    width: 100%; 
    z-index: 10;
}

/* Cyberpunk HUD Overlay */
.hud-overlay {
    position: fixed;
    top: 0;
    left: 0;
    width: 100vw;
    height: 100vh;
    pointer-events: none;
    z-index: 100;
    color: #00FFFF;
    font-family: 'IBM Plex Mono', 'Courier New', monospace;
}

/* Corner Frames */
.corner-frame {
    position: absolute;
    width: 80px;
    height: 80px;
    border: 2px solid #00FFFF;
    box-shadow: 0 0 20px #00FFFF, inset 0 0 20px rgba(0,255,255,0.1);
    animation: pulse-glow 2s ease-in-out infinite alternate;
}

.corner-tl { top: 20px; left: 20px; border-right: none; border-bottom: none; }
.corner-tr { top: 20px; right: 20px; border-left: none; border-bottom: none; }
.corner-bl { bottom: 20px; left: 20px; border-right: none; border-top: none; }
.corner-br { bottom: 20px; right: 20px; border-left: none; border-top: none; }

/* Status Bars */
.status-bar {
    position: absolute;
    background: rgba(0,0,0,0.8);
    border: 1px solid #00FFFF;
    padding: 8px 16px;
    font-size: 12px;
    font-weight: 500;
    letter-spacing: 1px;
    box-shadow: 0 0 15px rgba(0,255,255,0.5);
    text-transform: uppercase;
}

.status-top {
    top: 20px;
    left: 50%;
    transform: translateX(-50%);
    border-left: 3px solid #FFFF00;
    animation: data-stream 3s linear infinite;
}

.status-bar.status-encryption {
    position: absolute;
    top: 70px;
    left: 120px;
    background: rgba(0,0,0,0.9);
    border-color: #FF00FF;
    color: #FF00FF;
}

.coords {
    bottom: 20px;
    left: 120px;
    background: rgba(0,0,0,0.9);
    font-size: 10px;
    border-color: #00FFFF;
}

.timestamp {
    bottom: 20px;
    right: 120px;
    background: rgba(0,0,0,0.9);
    font-size: 10px;
    border-color: #FFFF00;
    color: #FFFF00;
}

.data-stream {
    position: absolute;
    right: 20px;
    top: 120px;
    width: 200px;
    height: 250px;
    background: rgba(0,0,0,0.9);
    border: 1px solid #00FFFF;
    padding: 10px;
    font-size: 8px;
    overflow: hidden;
    box-shadow: 0 0 15px rgba(0,255,255,0.3);
}

/* Scan Lines */
.scan-lines {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: repeating-linear-gradient(
        0deg,
        transparent,
        transparent 2px,
        rgba(0,255,255,0.03) 2px,
        rgba(0,255,255,0.03) 4px
    );
    animation: scan-move 8s linear infinite;
    pointer-events: none;
}

/* Tooltip */
.cyberpunk-tooltip {
    position: absolute;
    background: rgba(0,0,0,0.95);
    border: 2px solid #00FFFF;
    padding: 12px;
    font-size: 11px;
    color: #00FFFF;
    box-shadow: 0 0 25px rgba(0,255,255,0.6), inset 0 0 15px rgba(0,255,255,0.1);
    z-index: 1000;
    pointer-events: none;
    font-family: 'IBM Plex Mono', monospace;
    letter-spacing: 0.5px;
    border-radius: 0;
    transform: translateX(-50%) translateY(-100%);
    margin-top: -10px;
}

.cyberpunk-tooltip::before {
    content: '';
    position: absolute;
    top: 100%;
    left: 50%;
    transform: translateX(-50%);
    border: 8px solid transparent;
    border-top-color: #00FFFF;
}

.cyberpunk-tooltip .distance { color: #FF00FF; }
.cyberpunk-tooltip .time { color: #FFFF00; }

/* Animations */
@keyframes pulse-glow {
    0% { box-shadow: 0 0 20px #00FFFF, inset 0 0 20px rgba(0,255,255,0.1); }
    100% { box-shadow: 0 0 35px #00FFFF, inset 0 0 25px rgba(0,255,255,0.2); }
}

@keyframes scan-move {
    0% { transform: translateY(-100%); }
    100% { transform: translateY(100vh); }
}

@keyframes data-stream {
    0% { border-left-color: #FFFF00; }
    33% { border-left-color: #00FFFF; }
    66% { border-left-color: #FF00FF; }
    100% { border-left-color: #FFFF00; }
}

@keyframes glitch {
    0% { transform: translateX(0); }
    20% { transform: translateX(-2px); }
    40% { transform: translateX(2px); }
    60% { transform: translateX(-1px); }
    80% { transform: translateX(1px); }
    100% { transform: translateX(0); }
}

.glitch {
    animation: glitch 0.3s ease-in-out;
}

/* Pulse animations for cyberpunk effect */
@keyframes pulse-line {
    0% { 
        filter: drop-shadow(0 0 5px currentColor);
        opacity: 0.8;
    }
    50% { 
        filter: drop-shadow(0 0 20px currentColor) drop-shadow(0 0 35px currentColor);
        opacity: 1;
    }
    100% { 
        filter: drop-shadow(0 0 5px currentColor);
        opacity: 0.8;
    }
}

@keyframes pulse-point {
    0% { 
        filter: drop-shadow(0 0 8px currentColor);
    }
    50% { 
        filter: drop-shadow(0 0 25px currentColor) drop-shadow(0 0 40px currentColor);
    }
    100% { 
        filter: drop-shadow(0 0 8px currentColor);
    }
}

/* --- MOBILE RESPONSIVE CYBERPUNK HUD --- */
@media (max-width: 600px) {
  #map {
    top: 0 !important;
    bottom: 0 !important;
    height: 100vh !important;
    width: 100vw !important;
    position: fixed !important;
    z-index: 1;
  }
  .hud-overlay {
    width: 100vw;
    height: 100vh;
    pointer-events: none;
    z-index: 10;
  }
  .corner-frame {
    display: none !important;
  }
  .status-bar {
    font-size: 10px;
    padding: 4px 8px;
    max-width: 90vw;
    box-sizing: border-box;
  }
  .status-top {
    top: 4px;
    left: 50%;
    transform: translateX(-50%);
    min-width: 60vw;
    max-width: 95vw;
    text-align: center;
    border-width: 2px;
    font-size: 12px;
    padding: 4px 0;
  }
  .status-bar.status-encryption {
    top: 40px;
    left: 50%;
    transform: translateX(-50%);
    font-size: 10px;
    padding: 3px 8px;
    min-width: unset;
    max-width: 80vw;
    border-width: 2px;
    text-align: center;
    background: rgba(0,0,0,0.9);
    border-color: #FF00FF;
    color: #FF00FF;
  }
  .coords {
    bottom: 70px;
    left: 8px;
    font-size: 9px;
    padding: 2px 6px;
    border-width: 2px;
    background: rgba(0,0,0,0.8);
  }
  .timestamp {
    bottom: 70px;
    right: 8px;
    font-size: 9px;
    padding: 2px 6px;
    border-width: 2px;
    background: rgba(0,0,0,0.8);
  }
  .data-stream {
    display: none;
    position: fixed;
    left: 50%;
    bottom: 100px;
    transform: translateX(-50%);
    width: 92vw;
    max-width: 340px;
    height: 180px;
    font-size: 9px;
    z-index: 20;
    border-radius: 8px;
    padding: 8px 6px;
    background: rgba(0,0,0,0.95);
    box-shadow: 0 0 10px #00FFFF44;
    overflow-y: auto;
  }
  .data-stream.active {
    display: block;
  }
  .scan-lines {
    display: none;
  }
  /* Bot√≥n flotante para mostrar el data stream */
  .floating-btn {
    position: fixed;
    bottom: 110px;
    right: 16px;
    z-index: 50;
    background: #00FFFF;
    color: #000;
    border-radius: 50%;
    width: 44px;
    height: 44px;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 1.5rem;
    box-shadow: 0 2px 8px #000a;
    border: none;
    pointer-events: auto;
  }
}
</style>
</head>
<body>
<div id="map"></div>

<!-- Cyberpunk HUD Overlay -->
<div class="hud-overlay">
    <!-- Corner Frames -->
    <div class="corner-frame corner-tl"></div>
    <div class="corner-frame corner-tr"></div>
    <div class="corner-frame corner-bl"></div>
    <div class="corner-frame corner-br"></div>
    
    <!-- Status Bars -->
    <div class="status-bar status-top">Pizza Spider Finder 360 ACTIVATED</div>
    <div class="status-bar status-encryption">üîí ENCRYPTED</div>
    <div class="status-bar coords" id="coords-display">GPS: --- , ---</div>
    <div class="status-bar timestamp" id="timestamp-display">UTC: --:--:--</div>
    
    <!-- Data Stream (colapsable en m√≥vil) -->
    <div class="data-stream" id="dataStreamPanel">
        <div style="color: #FF00FF; margin-bottom: 10px;">DATA STREAM</div>
        <div id="stream-content" style="font-size: 7px; line-height: 1.2;"></div>
    </div>
    <!-- Bot√≥n flotante solo visible en m√≥vil -->
    <button class="floating-btn" id="toggleDataStreamBtn" style="display:none;">‚ò∞</button>
    <!-- Scan Lines -->
    <div class="scan-lines"></div>
</div>
<script>

let initLoad = true;

mapboxgl.accessToken = 'pk.eyJ1IjoiYWpyYWUiLCJhIjoiZjYyMDFjMTJhNjVhNjRmZGFmNjM1MjE1YTYxYjA3YmYifQ.FpDHggdIAaeBm7v0clXkrA';

// Configuraci√≥n inicial del mapa (ser√° actualizada con ubicaci√≥n real)
const map = new mapboxgl.Map({
    container: 'map',
    style: 'mapbox://styles/mapbox/dark-v11',
    center: [-78.4678, -0.1807], // fallback si no se obtiene ubicaci√≥n
    zoom: 14,
    projection: 'globe',
    maxZoom: 14
});

// Obtener ubicaci√≥n actual y centrar el mapa
if (navigator.geolocation) {
    navigator.geolocation.getCurrentPosition(
        (position) => {
            const userLocation = [position.coords.longitude, position.coords.latitude];
            map.setCenter(userLocation);
        },
        (error) => {
            console.log('Error obteniendo ubicaci√≥n:', error.message);
            // Mantiene el centro por defecto de Quito
        },
        {
            enableHighAccuracy: true,
            timeout: 10000,
            maximumAge: 600000
        }
    );
}

let airports;
let lastSearchCenter = null;
let lastSearchTime = 0;

// Funci√≥n para buscar pizzer√≠as usando Overpass API
async function searchPizzerias(center, radiusKm = 25) {
    const query = `
        [out:json][timeout:25];
        (
          node["amenity"="restaurant"]["cuisine"~"pizza",i](around:${radiusKm * 1000},${center.lat},${center.lng});
          way["amenity"="restaurant"]["cuisine"~"pizza",i](around:${radiusKm * 1000},${center.lat},${center.lng});
          node["shop"="pizza"](around:${radiusKm * 1000},${center.lat},${center.lng});
        );
        out center;
    `;
    
    try {
        const response = await fetch('https://overpass-api.de/api/interpreter', {
            method: 'POST',
            body: query
        });
        const data = await response.json();
        
        // Convertir a GeoJSON
        const features = data.elements.map((element, index) => {
            const lat = element.lat || (element.center && element.center.lat);
            const lon = element.lon || (element.center && element.center.lon);
            
            if (!lat || !lon) return null;
            
            return {
                type: "Feature",
                geometry: {
                    type: "Point",
                    coordinates: [lon, lat]
                },
                properties: {
                    name: element.tags.name || `Pizzer√≠a ${index + 1}`,
                    address: element.tags["addr:full"] || element.tags["addr:street"] || "Direcci√≥n no disponible",
                    type: element.tags.cuisine || "Pizza",
                    shopCode: `OSM${element.id}`
                }
            };
        }).filter(f => f !== null);
        
        return {
            type: "FeatureCollection",
            features: features
        };
    } catch (error) {
        console.error('Error buscando pizzer√≠as:', error);
        return { type: "FeatureCollection", features: [] };
    }
}

// Funci√≥n para verificar si necesitamos actualizar (cada 5min de distancia)
function shouldUpdate(currentCenter) {
    if (!lastSearchCenter) return true;
    
    const distance = turf.distance(
        turf.point([lastSearchCenter.lng, lastSearchCenter.lat]),
        turf.point([currentCenter.lng, currentCenter.lat]),
        { units: 'kilometers' }
    );
    
    // Aproximadamente 5 minutos en auto (5km a 60km/h)
    return distance > 5;
}

map.on('load', () => {
    map.once('idle', async () => {
        const center = map.getCenter();
        airports = await searchPizzerias(center);
        lastSearchCenter = center;
        lastSearchTime = Date.now();
        getSpoke(airports);
    });

    // Actualizar cuando se mueva el mapa
    let moveTimeout;
    map.on('move', () => {
        clearTimeout(moveTimeout);
        moveTimeout = setTimeout(async () => {
            const currentCenter = map.getCenter();
            
            if (shouldUpdate(currentCenter)) {
                airports = await searchPizzerias(currentCenter);
                lastSearchCenter = currentCenter;
                lastSearchTime = Date.now();
            }
            
            getSpoke(airports);
        }, 500); // Debounce para evitar muchas llamadas
    });
});

function getSpoke(airports) {
    const center = map.getCenter();
    const newPoint = turf.point([center.lng, center.lat]);
    buildSpoke(airports, newPoint);
}

function buildSpoke(airports, point) {
    let nearestAirports = turf.featureCollection([]);
    let nearestAirportLines = turf.featureCollection([]);
    let cleanedAirports = JSON.parse(JSON.stringify(airports));

    for (let i=1;i<=10;i++) {
        const nearest = turf.nearestPoint(point, cleanedAirports);
        const startLng = point.geometry.coordinates[0];
        const endLng = nearest.geometry.coordinates[0];
        
        if (startLng >= 90 && endLng <= -90) {
            nearest.geometry.coordinates[0] += 360;
        } else if (startLng <= -90 && endLng >= 90) {
            nearest.geometry.coordinates[0] -= 360;
        }

        const nearestLine = turf.lineString([point.geometry.coordinates, nearest.geometry.coordinates]);
        
        nearest.properties = {...nearest.properties, index: i-1};
        nearestAirports.features.push(nearest);
        nearestLine.properties = { index: i-1 };
        nearestAirportLines.features.push(nearestLine);

        const index = cleanedAirports.features.findIndex(n => n.properties.shopCode === nearest.properties.shopCode)
        if (index !== -1) {
            cleanedAirports.features.splice(index, 1);
        }
    }

    if (initLoad) {
        addLayers(airports, nearestAirports, nearestAirportLines);
    } else {
        // Animaci√≥n suave de las l√≠neas
        animateLines(nearestAirportLines);
        map.getSource('newPoint').setData(nearestAirports);
    }
}

// Funci√≥n para animar las l√≠neas como tent√°culos
function animateLines(newLines) {
    const currentLines = map.getSource('newLine')._data;
    
    if (!currentLines || !currentLines.features) {
        map.getSource('newLine').setData(newLines);
        return;
    }
    
    // Crear animaci√≥n paso a paso
    const steps = 20;
    let currentStep = 0;
    
    const animate = () => {
        if (currentStep >= steps) {
            map.getSource('newLine').setData(newLines);
            return;
        }
        
        const progress = currentStep / steps;
        const easedProgress = easeInOutSine(progress);
        
        const interpolatedLines = {
            type: 'FeatureCollection',
            features: newLines.features.map((newLine, index) => {
                const oldLine = currentLines.features[index];
                
                if (!oldLine) return newLine;
                
                const newCoords = newLine.geometry.coordinates;
                const oldCoords = oldLine.geometry.coordinates;
                
                // Interpolaci√≥n suave entre coordenadas
                const interpolatedCoords = [
                    newCoords[0], // mantener punto de origen
                    [
                        oldCoords[1][0] + (newCoords[1][0] - oldCoords[1][0]) * easedProgress,
                        oldCoords[1][1] + (newCoords[1][1] - oldCoords[1][1]) * easedProgress
                    ]
                ];
                
                return {
                    ...newLine,
                    geometry: {
                        ...newLine.geometry,
                        coordinates: interpolatedCoords
                    }
                };
            })
        };
        
        map.getSource('newLine').setData(interpolatedLines);
        currentStep++;
        requestAnimationFrame(animate);
    };
    
    animate();
}

// Funci√≥n de easing para movimiento org√°nico
function easeInOutSine(t) {
    return -(Math.cos(Math.PI * t) - 1) / 2;
}

function addLayers(airports, nearest, route) {
    initLoad = false;

    map.addSource('points', {
        'type': 'geojson',
        'data': airports
    });

    map.addSource('newPoint', {
        'type': 'geojson',
        'data': nearest
    });

    map.addSource('newLine', {
        'type': 'geojson',
        'data': route
    });

    map.addLayer({
        'id': 'routeLayer',
        'type': 'line',
        'source': 'newLine',
        'layout': {
            'line-join': 'round',
            'line-cap': 'round'
        },
        'paint': {
            'line-color': [
                'case',
                ['==', ['%', ['get', 'index'], 3], 0], '#00FFFF',
                ['==', ['%', ['get', 'index'], 3], 1], '#FF00FF', 
                '#FFFF00'
            ],
            'line-width': [
                'interpolate',
                ['linear'],
                ['zoom'],
                0,
                0.5,
                3,
                4
            ],
            'line-opacity': [
                'interpolate',
                ['linear'],
                ['zoom'],
                0,
                0.6,
                14,
                0.9
            ]
        }
    });

    map.addLayer({
        'id': 'globe-points',
        'type': 'circle',
        'source': 'points',
        'paint': {
            'circle-radius': [
                'interpolate',
                ['linear'],
                ['zoom'],
                0,
                0.1,
                3,
                3
            ],
            'circle-opacity': 1,
            'circle-blur': 0,
            'circle-color': '#00FFFF',
            'circle-stroke-width': 2,
            'circle-stroke-color': '#00FFFF'
        }
    });

    map.addLayer({
        'id': 'globe-newPoint',
        'type': 'circle',
        'source': 'newPoint',
        'paint': {
            'circle-radius': [
                'interpolate',
                ['linear'],
                ['zoom'],
                0,
                0.25,
                3,
                4
            ],
            'circle-opacity': 1,
            'circle-blur': 0,
            'circle-color': [
                'case',
                ['==', ['%', ['get', 'index'], 3], 0], '#00FFFF',
                ['==', ['%', ['get', 'index'], 3], 1], '#FF00FF',
                '#FFFF00'
            ],
            'circle-stroke-width': 3,
            'circle-stroke-color': '#FFFFFF'
        }
    });

    map.addLayer({
        'id': 'pizza-labels',
        'type': 'symbol',
        'source': 'newPoint',
        'layout': {
            'text-field': ['get', 'name'],
            'text-font': ['Open Sans Semibold', 'Arial Unicode MS Bold'],
            'text-offset': [0, 1.25],
            'text-anchor': 'top',
            'text-size': 12
        },
        'paint': {
            'text-color': '#00FFFF',
            'text-halo-color': '#000000',
            'text-halo-width': 3
        }
    });
}

// Variables globales para tooltips
let tooltip = null;
let currentHoverFeature = null;

// Update HUD elements
function updateHUD() {
    const center = map.getCenter();
    const now = new Date();
    
    // Update coordinates
    document.getElementById('coords-display').textContent = 
        `GPS: ${center.lat.toFixed(6)}, ${center.lng.toFixed(6)}`;
    
    // Update timestamp
    document.getElementById('timestamp-display').textContent = 
        `UTC: ${now.toUTCString().split(' ')[4]}`;
    
    // Update data stream
    updateDataStream();
}

// Data stream content
function updateDataStream() {
    const streamContent = document.getElementById('stream-content');
    const messages = [
        '> SCANNING NETWORK...',
        '> LOCATION ACQUIRED',
        '> ANALYZING TARGETS',
        '> CALCULATING ROUTES',
        '> ENCRYPTION ACTIVE',
        '> SIGNAL STRENGTH: 98%',
        '> SURVEILLANCE MODE: ON',
        '> DATA PACKETS: 1247',
        '> UPLINK STATUS: SECURE'
    ];
    
    streamContent.innerHTML = messages.map(msg => 
        `<div style="color: ${Math.random() > 0.5 ? '#00FFFF' : '#FF00FF'}; margin: 2px 0;">${msg}</div>`
    ).join('');
}

// Create tooltip
function createTooltip(feature, lngLat) {
    if (tooltip) {
        tooltip.remove();
    }
    
    const center = map.getCenter();
    const distance = turf.distance(
        turf.point([center.lng, center.lat]),
        turf.point(feature.geometry.coordinates),
        { units: 'meters' }
    );
    
    const walkTime = Math.round(distance / 5000 * 60); // 5 km/h
    const driveTime = Math.round(distance / 30000 * 60); // 30 km/h urban
    
    tooltip = document.createElement('div');
    tooltip.className = 'cyberpunk-tooltip';
    tooltip.innerHTML = `
        <div style="color: #00FFFF; font-weight: bold; margin-bottom: 5px;">${feature.properties.name}</div>
        <div class="distance">üìç ${Math.round(distance)}m</div>
        <div class="time">üö∂ ${walkTime} min | üöó ${driveTime} min</div>
    `;
    
    const point = map.project(lngLat);
    tooltip.style.left = point.x + 'px';
    tooltip.style.top = point.y + 'px';
    
    document.body.appendChild(tooltip);
}

// Inicializar eventos del mapa despu√©s de que se cargue
map.on('load', () => {
    // Mouse events for tooltips
    map.on('mouseenter', 'globe-newPoint', (e) => {
        map.getCanvas().style.cursor = 'pointer';
        currentHoverFeature = e.features[0];
        createTooltip(e.features[0], e.lngLat);
        
        // Add glitch effect occasionally
        if (Math.random() < 0.3) {
            const labels = document.querySelectorAll('.mapboxgl-marker');
            labels.forEach(label => {
                label.classList.add('glitch');
                setTimeout(() => label.classList.remove('glitch'), 300);
            });
        }
    });

    map.on('mouseleave', 'globe-newPoint', () => {
        map.getCanvas().style.cursor = '';
        if (tooltip) {
            tooltip.remove();
            tooltip = null;
        }
        currentHoverFeature = null;
    });

    map.on('mousemove', (e) => {
        if (currentHoverFeature && tooltip) {
            const point = map.project(e.lngLat);
            tooltip.style.left = point.x + 'px';
            tooltip.style.top = point.y + 'px';
        }
    });
});

// Update HUD every second
setInterval(updateHUD, 1000);
updateHUD();

// Mostrar bot√≥n flotante solo en m√≥vil
function checkMobileHUD() {
  const btn = document.getElementById('toggleDataStreamBtn');
  if (window.innerWidth <= 600) {
    btn.style.display = 'flex';
  } else {
    btn.style.display = 'none';
    document.getElementById('dataStreamPanel').classList.remove('active');
  }
}
window.addEventListener('resize', checkMobileHUD);
window.addEventListener('DOMContentLoaded', checkMobileHUD);

document.getElementById('toggleDataStreamBtn').onclick = function() {
  document.getElementById('dataStreamPanel').classList.toggle('active');
};

</script>
</body>
</html>
