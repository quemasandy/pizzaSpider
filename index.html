<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>Quito Pizza Finder</title>
<meta name="viewport" content="initial-scale=1,maximum-scale=1,user-scalable=no">
<link href="https://api.mapbox.com/mapbox-gl-js/v2.9.0-beta.2/mapbox-gl.css" rel="stylesheet">
<script src="https://api.mapbox.com/mapbox-gl-js/v2.9.0-beta.2/mapbox-gl.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@turf/turf@6/turf.min.js"></script>
<script src="https://d3js.org/d3.v4.min.js"></script>
<style>
body { margin: 0; padding: 0; }
#map { position: absolute; top: 0; bottom: 0; width: 100%; }
</style>
</head>
<body>
<div id="map"></div>
<script>

let initLoad = true;

mapboxgl.accessToken = 'pk.eyJ1IjoiYWpyYWUiLCJhIjoiZjYyMDFjMTJhNjVhNjRmZGFmNjM1MjE1YTYxYjA3YmYifQ.FpDHggdIAaeBm7v0clXkrA';

// Configuración inicial del mapa (será actualizada con ubicación real)
const map = new mapboxgl.Map({
    container: 'map',
    style: 'mapbox://styles/mapbox/dark-v11',
    center: [-78.4678, -0.1807], // fallback si no se obtiene ubicación
    zoom: 14,
    projection: 'globe',
    maxZoom: 14
});

// Obtener ubicación actual y centrar el mapa
if (navigator.geolocation) {
    navigator.geolocation.getCurrentPosition(
        (position) => {
            const userLocation = [position.coords.longitude, position.coords.latitude];
            map.setCenter(userLocation);
        },
        (error) => {
            console.log('Error obteniendo ubicación:', error.message);
            // Mantiene el centro por defecto de Quito
        },
        {
            enableHighAccuracy: true,
            timeout: 10000,
            maximumAge: 600000
        }
    );
}

let airports;
let lastSearchCenter = null;
let lastSearchTime = 0;

// Función para buscar pizzerías usando Overpass API
async function searchPizzerias(center, radiusKm = 25) {
    const query = `
        [out:json][timeout:25];
        (
          node["amenity"="restaurant"]["cuisine"~"pizza",i](around:${radiusKm * 1000},${center.lat},${center.lng});
          way["amenity"="restaurant"]["cuisine"~"pizza",i](around:${radiusKm * 1000},${center.lat},${center.lng});
          node["shop"="pizza"](around:${radiusKm * 1000},${center.lat},${center.lng});
        );
        out center;
    `;
    
    try {
        const response = await fetch('https://overpass-api.de/api/interpreter', {
            method: 'POST',
            body: query
        });
        const data = await response.json();
        
        // Convertir a GeoJSON
        const features = data.elements.map((element, index) => {
            const lat = element.lat || (element.center && element.center.lat);
            const lon = element.lon || (element.center && element.center.lon);
            
            if (!lat || !lon) return null;
            
            return {
                type: "Feature",
                geometry: {
                    type: "Point",
                    coordinates: [lon, lat]
                },
                properties: {
                    name: element.tags.name || `Pizzería ${index + 1}`,
                    address: element.tags["addr:full"] || element.tags["addr:street"] || "Dirección no disponible",
                    type: element.tags.cuisine || "Pizza",
                    shopCode: `OSM${element.id}`
                }
            };
        }).filter(f => f !== null);
        
        return {
            type: "FeatureCollection",
            features: features
        };
    } catch (error) {
        console.error('Error buscando pizzerías:', error);
        return { type: "FeatureCollection", features: [] };
    }
}

// Función para verificar si necesitamos actualizar (cada 5min de distancia)
function shouldUpdate(currentCenter) {
    if (!lastSearchCenter) return true;
    
    const distance = turf.distance(
        turf.point([lastSearchCenter.lng, lastSearchCenter.lat]),
        turf.point([currentCenter.lng, currentCenter.lat]),
        { units: 'kilometers' }
    );
    
    // Aproximadamente 5 minutos en auto (5km a 60km/h)
    return distance > 5;
}

map.on('load', () => {
    map.once('idle', async () => {
        const center = map.getCenter();
        airports = await searchPizzerias(center);
        lastSearchCenter = center;
        lastSearchTime = Date.now();
        getSpoke(airports);
    });

    // Actualizar cuando se mueva el mapa
    let moveTimeout;
    map.on('move', () => {
        clearTimeout(moveTimeout);
        moveTimeout = setTimeout(async () => {
            const currentCenter = map.getCenter();
            
            if (shouldUpdate(currentCenter)) {
                airports = await searchPizzerias(currentCenter);
                lastSearchCenter = currentCenter;
                lastSearchTime = Date.now();
            }
            
            getSpoke(airports);
        }, 500); // Debounce para evitar muchas llamadas
    });
});

function getSpoke(airports) {
    const center = map.getCenter();
    const newPoint = turf.point([center.lng, center.lat]);
    buildSpoke(airports, newPoint);
}

function buildSpoke(airports, point) {
    let nearestAirports = turf.featureCollection([]);
    let nearestAirportLines = turf.featureCollection([]);
    let cleanedAirports = JSON.parse(JSON.stringify(airports));

    for (let i=1;i<=10;i++) {
        const nearest = turf.nearestPoint(point, cleanedAirports);
        const startLng = point.geometry.coordinates[0];
        const endLng = nearest.geometry.coordinates[0];
        
        if (startLng >= 90 && endLng <= -90) {
            nearest.geometry.coordinates[0] += 360;
        } else if (startLng <= -90 && endLng >= 90) {
            nearest.geometry.coordinates[0] -= 360;
        }

        const nearestLine = turf.lineString([point.geometry.coordinates, nearest.geometry.coordinates]);
        
        nearestAirports.features.push(nearest);
        nearestAirportLines.features.push(nearestLine);

        const index = cleanedAirports.features.findIndex(n => n.properties.shopCode === nearest.properties.shopCode)
        if (index !== -1) {
            cleanedAirports.features.splice(index, 1);
        }
    }

    if (initLoad) {
        addLayers(airports, nearestAirports, nearestAirportLines);
    } else {
        // Animación suave de las líneas
        animateLines(nearestAirportLines);
        map.getSource('newPoint').setData(nearestAirports);
    }
}

// Función para animar las líneas como tentáculos
function animateLines(newLines) {
    const currentLines = map.getSource('newLine')._data;
    
    if (!currentLines || !currentLines.features) {
        map.getSource('newLine').setData(newLines);
        return;
    }
    
    // Crear animación paso a paso
    const steps = 20;
    let currentStep = 0;
    
    const animate = () => {
        if (currentStep >= steps) {
            map.getSource('newLine').setData(newLines);
            return;
        }
        
        const progress = currentStep / steps;
        const easedProgress = easeInOutSine(progress);
        
        const interpolatedLines = {
            type: 'FeatureCollection',
            features: newLines.features.map((newLine, index) => {
                const oldLine = currentLines.features[index];
                
                if (!oldLine) return newLine;
                
                const newCoords = newLine.geometry.coordinates;
                const oldCoords = oldLine.geometry.coordinates;
                
                // Interpolación suave entre coordenadas
                const interpolatedCoords = [
                    newCoords[0], // mantener punto de origen
                    [
                        oldCoords[1][0] + (newCoords[1][0] - oldCoords[1][0]) * easedProgress,
                        oldCoords[1][1] + (newCoords[1][1] - oldCoords[1][1]) * easedProgress
                    ]
                ];
                
                return {
                    ...newLine,
                    geometry: {
                        ...newLine.geometry,
                        coordinates: interpolatedCoords
                    }
                };
            })
        };
        
        map.getSource('newLine').setData(interpolatedLines);
        currentStep++;
        requestAnimationFrame(animate);
    };
    
    animate();
}

// Función de easing para movimiento orgánico
function easeInOutSine(t) {
    return -(Math.cos(Math.PI * t) - 1) / 2;
}

function addLayers(airports, nearest, route) {
    initLoad = false;

    map.addSource('points', {
        'type': 'geojson',
        'data': airports
    });

    map.addSource('newPoint', {
        'type': 'geojson',
        'data': nearest
    });

    map.addSource('newLine', {
        'type': 'geojson',
        'data': route
    });

    map.addLayer({
        'id': 'routeLayer',
        'type': 'line',
        'source': 'newLine',
        'layout': {
            'line-join': 'round',
            'line-cap': 'round'
        },
        'paint': {
            'line-color': '#39FF14',
            'line-width': [
                'interpolate',
                ['linear'],
                ['zoom'],
                0,
                0.5,
                3,
                4
            ],
            'line-opacity': [
                'interpolate',
                ['linear'],
                ['zoom'],
                0,
                0.6,
                14,
                0.9
            ]
        }
    });

    map.addLayer({
        'id': 'globe-points',
        'type': 'circle',
        'source': 'points',
        'paint': {
            'circle-radius': [
                'interpolate',
                ['linear'],
                ['zoom'],
                0,
                0.1,
                3,
                3
            ],
            'circle-opacity': 1,
            'circle-blur': 0,
            'circle-color': '#00BFFF'
        }
    });

    map.addLayer({
        'id': 'globe-newPoint',
        'type': 'circle',
        'source': 'newPoint',
        'paint': {
            'circle-radius': [
                'interpolate',
                ['linear'],
                ['zoom'],
                0,
                0.25,
                3,
                4
            ],
            'circle-opacity': 1,
            'circle-blur': 0,
            'circle-color': '#FFFFFF'
        }
    });

    map.addLayer({
        'id': 'pizza-labels',
        'type': 'symbol',
        'source': 'newPoint',
        'layout': {
            'text-field': ['get', 'name'],
            'text-font': ['Open Sans Semibold', 'Arial Unicode MS Bold'],
            'text-offset': [0, 1.25],
            'text-anchor': 'top',
            'text-size': 12
        },
        'paint': {
            'text-color': '#FFFFFF',
            'text-halo-color': '#003366',
            'text-halo-width': 2
        }
    });
}
</script>
</body>
</html>
